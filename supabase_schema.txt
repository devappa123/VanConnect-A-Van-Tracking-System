-- This script is fully idempotent. You can run it multiple times without errors.

-- 1. CREATE CUSTOM TYPES (ENUMS)
DO $$ BEGIN
    CREATE TYPE public.user_role AS ENUM ('student', 'driver', 'admin');
EXCEPTION WHEN duplicate_object THEN null; END $$;

DO $$ BEGIN
    CREATE TYPE public.complaint_status AS ENUM ('Pending', 'Resolved');
EXCEPTION WHEN duplicate_object THEN null; END $$;


-- 2. CREATE TABLES
CREATE TABLE IF NOT EXISTS public.users (
    id uuid NOT NULL PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    name text,
    email text UNIQUE,
    role public.user_role NOT NULL,
    avatar_url text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);

CREATE TABLE IF NOT EXISTS public.routes (
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    route_name text NOT NULL,
    start_latitude numeric NOT NULL,
    start_longitude numeric NOT NULL,
    end_latitude numeric NOT NULL,
    end_longitude numeric NOT NULL,
    stops jsonb,
    created_at timestamp with time zone NOT NULL DEFAULT now()
);

CREATE TABLE IF NOT EXISTS public.vans (
    id uuid NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
    van_no text NOT NULL UNIQUE,
    route_name text,
    driver_id uuid, -- Foreign key is added after drivers table is created
    capacity integer NOT NULL DEFAULT 0,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    route_id bigint -- Foreign key is added separately below for robustness
);

CREATE TABLE IF NOT EXISTS public.students (
    id uuid NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
    user_id uuid NOT NULL UNIQUE REFERENCES public.users(id) ON DELETE CASCADE,
    usn text,
    department text,
    phone text,
    van_id uuid REFERENCES public.vans(id) ON DELETE SET NULL
);

CREATE TABLE IF NOT EXISTS public.drivers (
    id uuid NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
    user_id uuid NOT NULL UNIQUE REFERENCES public.users(id) ON DELETE CASCADE,
    phone text,
    van_id uuid REFERENCES public.vans(id) ON DELETE SET NULL
);

-- Add the foreign key constraint from vans to drivers now that drivers table exists
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM pg_constraint
        WHERE conname = 'vans_driver_id_fkey' AND conrelid = 'public.vans'::regclass
    ) THEN
        ALTER TABLE public.vans
        ADD CONSTRAINT vans_driver_id_fkey
        FOREIGN KEY (driver_id) REFERENCES public.drivers(id) ON DELETE SET NULL;
    END IF;
END;
$$;

-- Fix for existing schemas: ensure route_id column exists before adding FK
ALTER TABLE public.vans ADD COLUMN IF NOT EXISTS route_id bigint;

-- Add the foreign key constraint from vans to routes
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM pg_constraint
        WHERE conname = 'vans_route_id_fkey' AND conrelid = 'public.vans'::regclass
    ) THEN
        ALTER TABLE public.vans
        ADD CONSTRAINT vans_route_id_fkey
        FOREIGN KEY (route_id) REFERENCES public.routes(id) ON DELETE SET NULL;
    END IF;
END;
$$;


CREATE TABLE IF NOT EXISTS public.locations (
    van_id uuid NOT NULL PRIMARY KEY REFERENCES public.vans(id) ON DELETE CASCADE,
    latitude double precision NOT NULL,
    longitude double precision NOT NULL,
    "timestamp" timestamp with time zone NOT NULL DEFAULT now()
);

CREATE TABLE IF NOT EXISTS public.complaints (
    id uuid NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
    student_id uuid NOT NULL REFERENCES public.students(id) ON DELETE CASCADE,
    driver_id uuid NOT NULL REFERENCES public.drivers(id) ON DELETE CASCADE,
    description text NOT NULL,
    status public.complaint_status NOT NULL DEFAULT 'Pending'::public.complaint_status,
    admin_reply text,
    created_at timestamp with time zone NOT NULL DEFAULT now()
);


-- 3. SETUP AUTH TRIGGER (CRITICAL FIX FOR PROFILE CREATION)
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER SET search_path = public
AS $$
BEGIN
  -- Insert into public.users table
  INSERT INTO public.users (id, name, email, role)
  VALUES (
    NEW.id,
    NEW.raw_user_meta_data->>'name',
    NEW.email,
    (NEW.raw_user_meta_data->>'role')::public.user_role
  );

  -- Based on role, insert into students or drivers table
  IF (NEW.raw_user_meta_data->>'role')::public.user_role = 'student' THEN
    INSERT INTO public.students (user_id, usn, phone)
    VALUES (
      NEW.id,
      NEW.raw_user_meta_data->>'usn',
      NEW.raw_user_meta_data->>'phone'
    );
  ELSIF (NEW.raw_user_meta_data->>'role')::public.user_role = 'driver' THEN
    INSERT INTO public.drivers (user_id, phone)
    VALUES (
      NEW.id,
      NEW.raw_user_meta_data->>'phone'
    );
  END IF;
  
  RETURN NEW;
END;
$$;

-- Drop trigger if exists and recreate to ensure it's up to date.
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();


-- 4. SETUP 'updated_at' TRIGGER
CREATE OR REPLACE FUNCTION public.moddatetime()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = now();
    RETURN NEW;
END;
$$ language 'plpgsql';

DROP TRIGGER IF EXISTS handle_updated_at ON public.users;
CREATE TRIGGER handle_updated_at
BEFORE UPDATE ON public.users
FOR EACH ROW
EXECUTE PROCEDURE public.moddatetime();


-- 5. ENABLE ROW LEVEL SECURITY (RLS) ON ALL TABLES
ALTER TABLE public.users ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.students ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.drivers ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.vans ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.locations ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.complaints ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.routes ENABLE ROW LEVEL SECURITY;


-- 6. ADD RLS POLICIES
-- RECURSION FIX: Helper functions to check roles. Using SECURITY DEFINER prevents recursion.
CREATE OR REPLACE FUNCTION is_admin()
RETURNS boolean AS $$
  SELECT EXISTS (SELECT 1 FROM public.users WHERE id = auth.uid() AND role = 'admin');
$$ LANGUAGE sql SECURITY DEFINER SET search_path = public;

CREATE OR REPLACE FUNCTION is_student()
RETURNS boolean AS $$
  SELECT EXISTS (SELECT 1 FROM public.users WHERE id = auth.uid() AND role = 'student');
$$ LANGUAGE sql SECURITY DEFINER SET search_path = public;

CREATE OR REPLACE FUNCTION is_driver()
RETURNS boolean AS $$
  SELECT EXISTS (SELECT 1 FROM public.users WHERE id = auth.uid() AND role = 'driver');
$$ LANGUAGE sql SECURITY DEFINER SET search_path = public;

-- RECURSION FIX: This SECURITY DEFINER function safely gets the current user's van_id
-- without triggering RLS, which breaks the recursive policy loop.
CREATE OR REPLACE FUNCTION get_my_van_id()
RETURNS uuid
LANGUAGE sql
SECURITY DEFINER SET search_path = public
AS $$
  SELECT van_id FROM public.students WHERE user_id = auth.uid()
  UNION ALL
  SELECT van_id FROM public.drivers WHERE user_id = auth.uid()
  LIMIT 1;
$$;

-- POLICIES for 'users' table
DROP POLICY IF EXISTS "Allow admin full access on users" ON public.users;
CREATE POLICY "Allow admin full access on users" ON public.users FOR ALL USING (is_admin()) WITH CHECK (is_admin());
DROP POLICY IF EXISTS "Allow users to view their own data" ON public.users;
CREATE POLICY "Allow users to view their own data" ON public.users FOR SELECT USING (auth.uid() = id);
DROP POLICY IF EXISTS "Allow users to update their own data" ON public.users;
CREATE POLICY "Allow users to update their own data" ON public.users FOR UPDATE USING (auth.uid() = id) WITH CHECK (auth.uid() = id);

-- RECURSION FIX: Policies for cross-viewing profiles between students and drivers.
DROP POLICY IF EXISTS "Allow drivers to view user profiles of their students" ON public.users;
CREATE POLICY "Allow drivers to view user profiles of their students" ON public.users
FOR SELECT USING (
  is_driver() AND
  EXISTS (
    SELECT 1 FROM public.students s
    WHERE s.user_id = users.id AND s.van_id = get_my_van_id()
  )
);

DROP POLICY IF EXISTS "Allow students to view driver user profile" ON public.users;
CREATE POLICY "Allow students to view driver user profile" ON public.users
FOR SELECT USING (
  is_student() AND
  EXISTS (
    SELECT 1 FROM public.drivers d
    WHERE d.user_id = users.id AND d.van_id = get_my_van_id()
  )
);


-- POLICIES for 'students' table
DROP POLICY IF EXISTS "Allow admin full access on students" ON public.students;
CREATE POLICY "Allow admin full access on students" ON public.students FOR ALL USING (is_admin()) WITH CHECK (is_admin());
DROP POLICY IF EXISTS "Allow student to view their own profile" ON public.students;
CREATE POLICY "Allow student to view their own profile" ON public.students FOR SELECT USING (auth.uid() = user_id);
DROP POLICY IF EXISTS "Allow student to update their own profile" ON public.students;
CREATE POLICY "Allow student to update their own profile" ON public.students FOR UPDATE USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);

DROP POLICY IF EXISTS "Allow drivers to view their assigned students" ON public.students;
CREATE POLICY "Allow drivers to view their assigned students" ON public.students
FOR SELECT USING (
  is_driver() AND get_my_van_id() = students.van_id
);


-- POLICIES for 'drivers' table
DROP POLICY IF EXISTS "Allow admin full access on drivers" ON public.drivers;
CREATE POLICY "Allow admin full access on drivers" ON public.drivers FOR ALL USING (is_admin()) WITH CHECK (is_admin());
DROP POLICY IF EXISTS "Allow driver to view their own profile" ON public.drivers;
CREATE POLICY "Allow driver to view their own profile" ON public.drivers FOR SELECT USING (auth.uid() = user_id);
DROP POLICY IF EXISTS "Allow driver to update their own profile" ON public.drivers;
CREATE POLICY "Allow driver to update their own profile" ON public.drivers FOR UPDATE USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);

DROP POLICY IF EXISTS "Allow students to view their assigned driver" ON public.drivers;
CREATE POLICY "Allow students to view their assigned driver" ON public.drivers
FOR SELECT USING (
  is_student() AND get_my_van_id() = drivers.van_id
);


-- POLICIES for 'vans' table
DROP POLICY IF EXISTS "Allow admin full access on vans" ON public.vans;
CREATE POLICY "Allow admin full access on vans" ON public.vans FOR ALL USING (is_admin()) WITH CHECK (is_admin());
DROP POLICY IF EXISTS "Allow authenticated users to view vans" ON public.vans;
CREATE POLICY "Allow authenticated users to view vans" ON public.vans FOR SELECT USING (auth.role() = 'authenticated');

-- POLICIES for 'locations' table (RLS FIX)
DROP POLICY IF EXISTS "Allow admin full access on locations" ON public.locations;
CREATE POLICY "Allow admin full access on locations" ON public.locations FOR ALL USING (is_admin()) WITH CHECK (is_admin());

-- Remove old, incorrect policies
DROP POLICY IF EXISTS "Allow authenticated users to see locations" ON public.locations;
DROP POLICY IF EXISTS "Allow driver to update their van location" ON public.locations;

-- New SELECT policy: Users can only see the location for their assigned van.
DROP POLICY IF EXISTS "Allow users to view their assigned van location" ON public.locations;
CREATE POLICY "Allow users to view their assigned van location" ON public.locations
FOR SELECT USING (
  van_id = get_my_van_id()
);

-- New INSERT/UPDATE/DELETE policy: Drivers can only manage the location for their own van.
DROP POLICY IF EXISTS "Allow drivers to manage their own van location" ON public.locations;
CREATE POLICY "Allow drivers to manage their own van location" ON public.locations
FOR ALL USING (
  is_driver() AND van_id = get_my_van_id()
)
WITH CHECK (
  is_driver() AND van_id = get_my_van_id()
);


-- POLICIES for 'complaints' table
DROP POLICY IF EXISTS "Allow admin full access on complaints" ON public.complaints;
CREATE POLICY "Allow admin full access on complaints" ON public.complaints FOR ALL USING (is_admin()) WITH CHECK (is_admin());
DROP POLICY IF EXISTS "Allow students to view their own complaints" ON public.complaints;
CREATE POLICY "Allow students to view their own complaints" ON public.complaints FOR SELECT USING (EXISTS (SELECT 1 FROM students WHERE user_id = auth.uid() and id = complaints.student_id));
DROP POLICY IF EXISTS "Allow students to create complaints" ON public.complaints;
CREATE POLICY "Allow students to create complaints" ON public.complaints FOR INSERT WITH CHECK (EXISTS (SELECT 1 FROM students WHERE user_id = auth.uid() and id = complaints.student_id));

-- POLICIES for 'routes' table
DROP POLICY IF EXISTS "Allow authenticated users to view routes" ON public.routes;
CREATE POLICY "Allow authenticated users to view routes" ON public.routes FOR SELECT USING (auth.role() = 'authenticated');
DROP POLICY IF EXISTS "Allow admin full access on routes" ON public.routes;
CREATE POLICY "Allow admin full access on routes" ON public.routes FOR ALL USING (is_admin()) WITH CHECK (is_admin());


-- 7. ADD VAN_NUMBER and NOTIFICATIONS
ALTER TABLE IF EXISTS public.drivers
  ADD COLUMN IF NOT EXISTS van_number text;

ALTER TABLE IF EXISTS public.students
  ADD COLUMN IF NOT EXISTS van_number text;

CREATE TABLE IF NOT EXISTS public.notifications (
  id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
  sender_driver_id uuid NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
  van_number text NOT NULL,
  message text NOT NULL,
  created_at timestamptz DEFAULT now()
);

-- Optional: index for fast lookups by van_number
CREATE INDEX IF NOT EXISTS idx_notifications_van_number ON public.notifications (van_number);

-- Enable RLS for notifications table
ALTER TABLE public.notifications ENABLE ROW LEVEL SECURITY;

-- Allow authenticated users to read notifications for their van
DROP POLICY IF EXISTS "Allow users to read van notifications" ON public.notifications;
CREATE POLICY "Allow users to read van notifications" ON public.notifications
FOR SELECT USING (
  (
    EXISTS (
      SELECT 1 FROM students WHERE user_id = auth.uid() AND students.van_number = notifications.van_number
    )
  ) OR (
    EXISTS (
      SELECT 1 FROM drivers WHERE user_id = auth.uid() AND drivers.van_number = notifications.van_number
    )
  ) OR is_admin()
);

-- Allow drivers to send notifications
DROP POLICY IF EXISTS "Allow drivers to send notifications" ON public.notifications;
CREATE POLICY "Allow drivers to send notifications" ON public.notifications
FOR INSERT WITH CHECK (
  EXISTS (
    SELECT 1 FROM drivers WHERE user_id = auth.uid() AND sender_driver_id = auth.uid()
  )
);

-- 8. ADD DATABASE FUNCTIONS FOR ATOMIC ASSIGNMENTS
CREATE OR REPLACE FUNCTION assign_van_to_driver(target_driver_id uuid, target_van_id uuid)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER SET search_path = public
AS $$
DECLARE
  current_van_id_for_driver uuid;
  current_driver_id_for_van uuid;
  target_van_no text;
BEGIN
  -- Get the driver's current van
  SELECT van_id INTO current_van_id_for_driver FROM drivers WHERE id = target_driver_id;
  
  -- Step 1: Un-assign the target driver from their old van's record
  IF current_van_id_for_driver IS NOT NULL THEN
    UPDATE vans SET driver_id = NULL WHERE id = current_van_id_for_driver;
  END IF;
  
  -- If we are assigning a new van...
  IF target_van_id IS NOT NULL THEN
    -- Get the target van's current driver and van_no
    SELECT driver_id, van_no INTO current_driver_id_for_van, target_van_no FROM vans WHERE id = target_van_id;

    -- Step 2: Un-assign the current driver from the target van (if any)
    IF current_driver_id_for_van IS NOT NULL AND current_driver_id_for_van != target_driver_id THEN
      UPDATE drivers SET van_id = NULL, van_number = NULL WHERE id = current_driver_id_for_van;
    END IF;
    
    -- Step 3: Update the target van's driver_id
    UPDATE vans SET driver_id = target_driver_id WHERE id = target_van_id;
  END IF;
  
  -- Step 4: Update the target driver's record
  UPDATE drivers
  SET
    van_id = target_van_id,
    van_number = target_van_no -- will be null if target_van_id is null
  WHERE id = target_driver_id;
END;
$$;

CREATE OR REPLACE FUNCTION assign_van_to_student(target_student_id uuid, target_van_id uuid)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER SET search_path = public
AS $$
DECLARE
  target_van_no text;
BEGIN
  IF target_van_id IS NOT NULL THEN
    SELECT van_no INTO target_van_no FROM vans WHERE id = target_van_id;
  END IF;
  
  UPDATE students
  SET
    van_id = target_van_id,
    van_number = target_van_no
  WHERE id = target_student_id;
END;
$$;